#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>
#include <chrono>
#include <thread>

using namespace cv;
using namespace std;

int main() {

    float thresh = 0.5f;
    bool invert_flag = false;
    Size res(640, 380);
    Size div(20, 32);        // width/height of each digit cell

    VideoCapture cap("BadApple!!.mp4");
    if(!cap.isOpened()) return -1;

    // Precompute grid cell origins
    vector<Point> boxes;
    for(int x = 0; x < res.width;  x += div.width)
        for(int y = 0; y < res.height; y += div.height)
            boxes.emplace_back(x, y);

    const float max_fps = 30.0f;
    const float frame_time = 1.0f / max_fps;

    auto prev = chrono::high_resolution_clock::now();
    int frame_count = 0;

    Mat frame, gray, frame_out(res, CV_8UC3);

    // ----------------------------------------------------------------------
    // 7-segment layout (pixel relative coords)
    // This version uses THICK segments, similar to your Python version.
    // ----------------------------------------------------------------------

    struct Seg {
        int ox, oy, w, h;   // offset x/y and width/height relative to div cell
    };

    // All parameters expressed as fractions of the cell size
    auto fx = [&](float k){ return int(k * div.width);  };
    auto fy = [&](float k){ return int(k * div.height); };

    vector<Seg> SEG = {
        { fx(0.20f), fy(0.05f), fx(0.60f), fy(0.12f) },   // A (top)
        { fx(0.78f), fy(0.10f), fx(0.12f), fy(0.40f) },   // B (upper right)
        { fx(0.78f), fy(0.50f), fx(0.12f), fy(0.40f) },   // C (lower right)
        { fx(0.20f), fy(0.85f), fx(0.60f), fy(0.12f) },   // D (bottom)
        { fx(0.10f), fy(0.50f), fx(0.12f), fy(0.40f) },   // E (lower left)
        { fx(0.10f), fy(0.10f), fx(0.12f), fy(0.40f) },   // F (upper left)
        { fx(0.20f), fy(0.45f), fx(0.60f), fy(0.12f) }    // G (middle)
    };

    while(true){

        auto start = chrono::high_resolution_clock::now();

        if(!cap.read(frame))
            break;

        resize(frame, frame, res);
        cvtColor(frame, gray, COLOR_BGR2GRAY);
        gray.convertTo(gray, CV_32F, 1.0/255.0);

        if(invert_flag)
            gray = 1.0f - gray;

        frame_out = Scalar(0,0,0);

        for(const auto &p : boxes) {

            for(const auto &s : SEG) {

                Rect roi(
                    p.x + s.ox,
                    p.y + s.oy,
                    s.w,
                    s.h
                );

                // Ensure ROI stays valid inside frame
                roi &= Rect(0,0,res.width,res.height);
                if(roi.width < 2 || roi.height < 2)
                    continue;

                float meanVal = mean(gray(roi))[0];

                if(meanVal >= thresh)
                    rectangle(frame_out, roi, Scalar(0,255,0), FILLED);
            }
        }

        imshow("7seg_binary", frame_out);

        int key = waitKey(1);
        if(key == 27) break;

        // FPS limit
        chrono::duration<float> elapsed = chrono::high_resolution_clock::now() - start;
        float diff = elapsed.count();
        if(diff < frame_time)
            this_thread::sleep_for(chrono::duration<float>(frame_time - diff));

        // FPS counter
        frame_count++;
        auto now = chrono::high_resolution_clock::now();
        if(chrono::duration<float>(now - prev).count() >= 1.0f){
            cout << "FPS: " << frame_count << endl;
            frame_count = 0;
            prev = now;
        }
    }

    return 0;
}

